#
# Makefile
#
# Created: 2014-01-29
# Author: Mikael Albertsson
#

CROSS   ?= avr-
CC      := $(CROSS)gcc
LD      := $(CROSS)gcc
OBJCOPY := $(CROSS)objcopy
OBJDUMP := $(CROSS)objdump
SIZE    := $(CROSS)size
AR      := $(CROSS)ar
AS      := $(CROSS)as

LIBS := -lm -lmooltipass

LIBDIRS := $(addprefix src/, CARD FLASH USB SPI OLEDMP UTILS AES)
LIBOBJS := $(foreach lib, $(LIBDIRS),$(patsubst src/%.c,build/%.o, $(wildcard $(lib)/*.c)))

AESDIRS := $(addprefix src/, AES AES/aes AES/gf256mul)
AESOBJS := $(foreach lib, $(AESDIRS),$(patsubst src/%.S,build/%.o, $(wildcard $(lib)/*.S)))

MOOLTIPASS_LIB := build/libmooltipass.a

OBJECTS := $(patsubst src/%.c,build/%.o, $(wildcard src/*.c))

TARGET  := mooltipass

# Compiler and linker configuration.
FORMAT  := ihex
MCU     := atmega32u4

# Set CONFIG=DEBUG in the shell from which you invoke make to build a debug
# build.
CONFIG  ?= RELEASE
DEFINES := F_CPU=16000000UL F_USB=16000000UL

CFLAGS  := -Wall -mmcu=$(MCU) -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums -ffunction-sections
CFLAGS  += -std=gnu99 -Werror
LDFLAGS := -Wl,-gc-sections

CFLAGS  += -Isrc $(addprefix -I , $(LIBDIRS) $(AESDIRS))

ifeq ($(CONFIG), RELEASE)
  DEFINES += NDEBUG
  CFLAGS  += -Os
else ifeq ($(CONFIG), DEBUG)
  DEFINES += DEBUG
  CFLAGS  += -O1 -g2 -Wa,-g
endif

# Add all defines, each prefixed with -D.
CFLAGS += $(foreach def,$(DEFINES),$(def:%=-D%))

.PHONY: all
all: $(TARGET).hex $(TARGET).eep $(TARGET).lss size

# Use the --mcu and --format=avr options if they are supported by the local
# avr-size program.
SIZEFLAGS :=
SIZE_HELP := $(shell $(SIZE) --help)
ifeq ($(findstring avr,$(filter --format={%},$(SIZE_HELP))),avr)
  SIZEFLAGS += --format=avr
endif
ifeq ($(findstring --mcu,$(SIZE_HELP)),--mcu)
  SIZEFLAGS += --mcu=$(MCU)
endif

# Display the size of generated elf file
.PHONY: size
size: $(TARGET).elf
	$(SIZE) $(SIZEFLAGS) $<

# Pattern rule to generate .d files from .c files. The .d files are make-files,
# generated by gcc with all the dependencies of the .c file. They are included
# above and will make all .o files depend on the correct prerequisite sources.
build/%.d: src/%.c
	@mkdir -p $(dir $@)
	@set -e; $(CC) -M -MT '$(<:src/%.c=build/%.o)' $(CFLAGS) $< | sed -e 's,\($*\)\.o[ :]*,\1.o $@: ,g' > $@

build/%.o: src/%.c
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

build/%.o: src/%.S
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

# Include the auto-generated make files that gcc generated in the %.d rule
# above.
-include $(OBJECTS:.o=.d) $(LIBOBJS:.o=.d)

# Target to link the object files into the final hex file.
$(TARGET).elf: $(OBJECTS) $(MOOLTIPASS_LIB)
	@echo "objs: $(OBJECTS)"
	@echo ""
	@echo "Linking $@"
	$(LD) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJECTS) -Lbuild $(LIBS)

# Extract the sections that should be in the .hex file from the .elf file.
%.hex: %.elf
	$(OBJCOPY) -O $(FORMAT) -R .eeprom -R .fuse -R .lock -R .signature $< $@

# Extract the eeprom parts from the .elf file.
%.eep: %.elf
	-$(OBJCOPY) -j .eeprom --set-section-flags=.eeprom="alloc,load" \
	--change-section-lma .eeprom=0 --no-change-warnings -O $(FORMAT) $< $@ || exit 0

%.lss: %.elf
	$(OBJDUMP) -h -S -z $< > $@

$(MOOLTIPASS_LIB): $(LIBOBJS) $(AESOBJS)
	$(AR) rcs $@ $?

.PHONY: fuses flash clean upload
# Target to set the fuses of the mooltipass device.
fuses:
	avrdude -p $(MCU) -U lfuse:w:0xff:m
	avrdude -p $(MCU) -U hfuse:w:0xd9:m
	avrdude -p $(MCU) -U efuse:w:0xfb:m

# Target to flash the hex image to the mooltipass device.
flash: $(TARGET).hex
	avrdude $(AVRDUDEFLAGS) -p $(MCU) -U flash:w:$<:i

upload: $(TARGET).hex
	avrdude $(AVRDUDEFLAGS) -p $(MCU) -U flash:w:$<:i


clean:
	-rm -f $(OBJECTS) $(OBJECTS:.o=.d) $(TARGET).hex $(TARGET).eep $(TARGET).lss $(TARGET).elf
	-rm -rf build
