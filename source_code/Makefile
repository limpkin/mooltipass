#
# Makefile
#
# Created: 2014-01-29
# Author: Mikael Albertsson
#

CROSS   ?= avr-
CC      := $(CROSS)gcc
LD      := $(CROSS)gcc
OBJCOPY := $(CROSS)objcopy
OBJDUMP := $(CROSS)objdump
SIZE    := $(CROSS)size
AR      := $(CROSS)ar
AS      := $(CROSS)as
BOOTLOADER  ?= false

# Mooltipass version: vMAJOR.MINOR
VERSION := v0.8

# If we are in a git controlled dir, let (matching) tag override version
git_hash := $(shell git rev-parse --verify --short HEAD 2>/dev/null)
ifneq (,$(git_hash))
  VERSION := $(shell git describe --tags --match $(VERSION)* --dirty 2>/dev/null)
  ifeq (,$(VERSION))
    # Oops, no matching tags, fall back to git hash
    VERSION := g$(git_hash)
  endif
endif


ifneq ($(BOOTLOADER), true)

TARGET  := mooltipass

# LTO is available in avr-gcc 4.9.2 of Ubuntu 16.04 and avr-gcc 5.3 of Arch
CFLAGS  += -flto -fuse-linker-plugin
LDFLAGS  += -flto -fuse-linker-plugin

# Some helpers to get all the .c and .h files.
# $(TARGET) is included inside $(OBJECTS).
LIBDIRS := $(addprefix src/, GUI CARD FLASH USB SPI OLEDMP UTILS AES NODEMGMT RNG PWM TOUCH LOGIC OLEDMINI MINI)
LIBOBJS := $(foreach lib, $(LIBDIRS),$(patsubst src/%.c,build/%.o, $(wildcard $(lib)/*.c)))
OBJECTS := $(patsubst src/%.c,build/%.o, $(filter-out src/bootloader_main.c, $(wildcard src/*.c)))

else

# Bootloader build settings
TARGET  := mooltipass_bootloader
OBJECTS := $(patsubst src/%.c,build/%.o, src/bootloader_main.c)
LIBDIRS := $(addprefix src/, GUI CARD FLASH USB SPI OLEDMP UTILS AES NODEMGMT RNG PWM TOUCH LOGIC OLEDMINI)
OBJDIRS := $(patsubst src/%.c,build/%.o, $(addprefix src/, FLASH SPI AES))
LIBOBJS := $(foreach lib, $(OBJDIRS), $(patsubst src/%.c,build/%.o, $(filter-out src/AES/aes256_ctr_test.c src/FLASH/flash_test.c src/AES/aes256_nessie_test.c, $(wildcard $(lib)/*.c))))
DEFINES += MINI_BOOTLOADER

# Special bootloader flags
LDFLAGS     += -Wl,--section-start=.text=$(BOOT_START_OFFSET) $(BOOT_API_LD_FLAGS) -nostartfiles

# Flash size and bootloader section sizes of the target, in KB. These must
# match the target's total FLASH size and the bootloader size set in the
# device's fuses.
FLASH_SIZE_KB           := 32
BOOT_SECTION_SIZE_KB    := 4

# Bootloader address calculation formulas
# Do not modify these macros, but rather modify the dependent values above.
CALC_ADDRESS_IN_HEX   = $(shell printf "0x%X" $$(( $(1) )) )
BOOT_START_OFFSET     = $(call CALC_ADDRESS_IN_HEX, ($(FLASH_SIZE_KB) - $(BOOT_SECTION_SIZE_KB)) * 1024 )
BOOT_SEC_OFFSET       = $(call CALC_ADDRESS_IN_HEX, ($(FLASH_SIZE_KB) * 1024) - ($(strip $(1))) )

# Bootloader linker section flags for relocating the API table sections to
# known FLASH addresses - these should not normally be user-edited.
BOOT_SECTION_LD_FLAG  = -Wl,--section-start=$(strip $(1))=$(call BOOT_SEC_OFFSET, $(3)) -Wl,--undefined=$(strip $(2))
BOOT_API_LD_FLAGS    += $(call BOOT_SECTION_LD_FLAG, .spmfunc, spmfunc, 128)

endif

# Compiler and linker configuration.
FORMAT  := ihex
MCU     := atmega32u4

# Set CONFIG=DEBUG in the shell from which you invoke make to build a debug
# build.
CONFIG  ?= RELEASE
DEFINES += F_CPU=16000000UL F_USB=16000000UL
#DEFINES := F_CPU=16000000UL F_USB=16000000UL MOOLTIPASS_VERSION="\"$(VERSION)\""

CFLAGS  += -Wall -mmcu=$(MCU) -funsigned-char -funsigned-bitfields -fpack-struct
CFLAGS  += -fshort-enums -ffunction-sections -fdata-sections
CFLAGS  += -Werror
CFLAGS  += -std=gnu99
CFLAGS  += -mcall-prologues
CFLAGS  += -Isrc $(addprefix -I , $(LIBDIRS))

# new from dmbs
CFLAGS  += -fno-inline-small-functions

# not used normally
#CFLAGS  += -Wstrict-prototypes
#CFLAGS  += -fno-strict-aliasing
CFLAGS  += -mrelax
CFLAGS  += -x c
CFLAGS  += -MD
CFLAGS  += -MP

LDFLAGS += -Wl,--gc-sections -mrelax
LDFLAGS += -mmcu=$(MCU)
LDFLAGS += -Wl,--start-group -Wl,-lm -Wl,--end-group
LDFLAGS += -Wl,-Map="${TARGET}.map"
#LDFLAGS  += -Werror

ifeq ($(CONFIG), RELEASE)
  DEFINES += NDEBUG
  CFLAGS  += -Os
else ifeq ($(CONFIG), DEBUG)
  DEFINES += DEBUG
  CFLAGS  += -O1 -g2 -Wa,-g
endif

# Add all defines, each prefixed with -D.
CFLAGS += $(foreach def,$(DEFINES),$(def:%=-D%))

.PHONY: all
all: $(TARGET).hex $(TARGET).eep $(TARGET).lss size

# Use the --mcu and --format=avr options if they are supported by the local
# avr-size program.
SIZEFLAGS :=
SIZE_HELP := $(shell $(SIZE) --help)
ifeq ($(findstring avr,$(filter --format={%},$(SIZE_HELP))),avr)
  SIZEFLAGS += --format=avr
endif
ifeq ($(findstring --mcu,$(SIZE_HELP)),--mcu)
  SIZEFLAGS += --mcu=$(MCU)
endif

# Display the size of generated elf file
.PHONY: size
size: $(TARGET).elf
	$(SIZE) $(SIZEFLAGS) $<

test:
	echo "build $(build)"

# Pattern rule to generate .d files from .c files. The .d files are make-files,
# generated by gcc with all the dependencies of the .c file. They are included
# above and will make all .o files depend on the correct prerequisite sources.
build/%.d: src/%.c
	@mkdir -p $(dir $@)
	@set -e; $(CC) -M -MT '$(<:src/%.c=build/%.o)' $(CFLAGS) $< | sed -e 's,\($*\)\.o[ :]*,\1.o $@: ,g' > $@

build/%.o: src/%.c
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

build/%.o: src/%.S
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

# Include the auto-generated make files that gcc generated in the %.d rule
# above.
-include $(OBJECTS:.o=.d) $(LIBOBJS:.o=.d)

# Target to link the object files into the final hex file.
$(TARGET).elf: $(OBJECTS) $(LIBOBJS)
	@echo "objs: $(OBJECTS)"
	@echo ""
	@echo "Linking $@"
	$(LD) $(LDFLAGS) -o $@ $(OBJECTS) $(LIBOBJS)

# Extract the sections that should be in the .hex file from the .elf file.
%.hex: %.elf
	$(OBJCOPY) -O $(FORMAT) -R .eeprom -R .fuse -R .lock -R .signature $< $@

# Extract the eeprom parts from the .elf file.
%.eep: %.elf
	-$(OBJCOPY) -j .eeprom --set-section-flags=.eeprom="alloc,load" \
	--change-section-lma .eeprom=0 --no-change-warnings -O $(FORMAT) $< $@ || exit 0

%.lss: %.elf
	$(OBJDUMP) -h -S -z $< > $@

release: clean $(TARGET).hex
	# tag the current git state with the next build number, then build that version
	@echo "Release build $(VERSION)"
	#git tag build.$(version_build)
	#git push --tags
	@cp $(TARGET).hex $(TARGET).$(VERSION).hex

.PHONY: fuses flash clean upload
# Target to set the fuses of the mooltipass device.
fuses:
	avrdude -p $(MCU) -U lfuse:w:0xff:m
	avrdude -p $(MCU) -U hfuse:w:0xd9:m
	avrdude -p $(MCU) -U efuse:w:0xfb:m

# Target to flash the hex image to the mooltipass device.
flash: $(TARGET).hex
	avrdude $(AVRDUDEFLAGS) -p $(MCU) -U flash:w:$<:i

# Upload the hex image via the dfu bootloader
upload: $(TARGET).hex
	@echo "The following will request root access"
	sudo dfu-programmer atmega32u4 erase
	sudo dfu-programmer atmega32u4 flash $<
	@printf 'Remove or flip the card over and then press Enter to restart Mooltipass';\
		read ENTER; \
		echo "Restarting Mooltipass"; \
		sudo dfu-programmer atmega32u4 start

# Upload the hex image via the dfu bootloader
load: $(TARGET).hex
	dfu-programmer atmega32u4 erase
	dfu-programmer atmega32u4 flash $<
	dfu-programmer atmega32u4 start


clean:
	-rm -f $(OBJECTS) $(OBJECTS:.o=.d) $(TARGET).hex $(TARGET).eep $(TARGET).lss $(TARGET).elf
	-rm -rf build
